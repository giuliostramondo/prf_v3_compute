package prf_v3_compute;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

class prf_v2Kernel extends Kernel {

    private static final DFEType type = PRFConstants.type;
    static int p = PRFConstants.p;
    static int q = PRFConstants.q;
    //TODO trying remove below
//    public Memory<DFEVar> memorymodules [][] ;
    protected prf_v2Kernel(KernelParameters parameters) {
        super(parameters);
//        //TODO trying remove below
//        memorymodules =new Memory[p][q];
//        for(int i =0 ; i< p ; i++){
//            for(int j =0; j< q; j++)
//                memorymodules[i][j] = mem.alloc(type, PRFConstants.MEMORY_DEPTH);
//
//        }
        //TODO trying remove above

        //IMPORTANT without this optimization the default rounding mode is to the nearest-integer
        optimization.pushRoundingMode(RoundingMode.TRUNCATE);

        DFEVar index_i = io.input("index_i", type);
        DFEVar index_j = io.input("index_j", type);
        DFEVar acc_type = io.input("acc_type", type);
        DFEVar write_enable = io.input("write_enable", type);
        //DFEVar compute = io.input("compute", type);
        DFEVar compute = io.scalarInput("compute", dfeInt(32));
        compute.simWatch("compute_b");
        DFEVar input_data_arr[][] = new DFEVar[p][q];
        for(int i =0 ; i< p ; i++)
            for(int j =0; j< q; j++){
            input_data_arr[i][j] = io.input("input_data_arr"+i+"_"+j, type);
        }

        DFEVector<DFEVar> aguOutput = Utils.AGU(index_i, index_j, acc_type);
        DFEVar in_memory_addr[][] = Utils.A_standard(aguOutput);
        DFEVar reordering_signal_i[][];
        DFEVar reordering_signal_j[][];
        DFEVar inv_reordering_signal_i[][];
        DFEVar inv_reordering_signal_j[][];
        DFEVar reordered_in_memory_addr[];
        DFEVar reordered_input_data_arr[][];
        reordering_signal_i= Utils.MBlock_i(aguOutput);
        reordering_signal_j = Utils.MBlock_j(aguOutput);
        if(PRFConstants.INV_M){
            inv_reordering_signal_i = Utils.inv_MBlock_i(aguOutput, acc_type);
            inv_reordering_signal_j = Utils.inv_MBlock_j(aguOutput, acc_type);
            reordered_in_memory_addr = Utils.Crossbar(in_memory_addr, inv_reordering_signal_i, inv_reordering_signal_j);
            reordered_input_data_arr = Utils.Crossbar_2d(input_data_arr, inv_reordering_signal_i, inv_reordering_signal_j);
        }else{
            //reordering_signal_i= Utils.MBlock_i(aguOutput);
            //reordering_signal_j = Utils.MBlock_j(aguOutput);
            reordered_in_memory_addr = Utils.Inv_Crossbar(in_memory_addr, reordering_signal_i, reordering_signal_j);
            reordered_input_data_arr = Utils.Inv_Crossbar_2d(input_data_arr, reordering_signal_i, reordering_signal_j);
        }
        DFEVar mem_out[][]=new DFEVar[p][q];
        DFEVar mem_in[][]=new DFEVar[p][q];
//        DFEVar reordered_in_memory_addr_skewed[]=new DFEVar[p*q];
//        DFEVar write_enable_skewed=stream.offset(write_enable,-2);
//        DFEVar reordered_input_data_arr_skewed[][]=new DFEVar[p][q];
//        DFEVar reordering_signal_i_sk[][] =new DFEVar[p][q];
//        DFEVar reordering_signal_j_sk[][] =new DFEVar[p][q];
//        for(int i =0;i<p*q;i++){
//            reordered_in_memory_addr_skewed[i]=stream.offset(reordered_in_memory_addr[i],-2);
//            reordered_input_data_arr_skewed[i/q][i%q]=stream.offset(reordered_input_data_arr[i/q][i%q],-2);
//            reordering_signal_i_sk[i/q][i%q]=stream.offset(reordering_signal_i[i/q][i%q],-2);
//            reordering_signal_j_sk[i/q][i%q]=stream.offset(reordering_signal_j[i/q][i%q],-2);
//        }
        //TODO trying uncomment below
        optimization.pushNoPipelining();
        for(int i =0 ; i< p ; i++)
            for(int j =0; j< q; j++){
                //mem_out[i][j] =type.newInstance(this);
                mem_out[i][j] = constant.var(0);
            }
        compute.simWatch("compute_bla");
        compute.eq(1).simWatch("compute_eq");
        for(int i =0 ; i< p ; i++)
            for(int j =0; j< q; j++){
                //The comparison and sum introduce a delay in the loop
                //Skewing the mem_out update to -2 solves the problem, but all the other signal
                //are now wrong and they need to be delayed.
                //however adding the delay does not solve the problem.
                //Debug of the signal in comparison to the working case is required.

                //mem_in[i][j]=reordered_input_data_arr[i][j];
                //mem_in[i][j] = compute.eq(1)? mem_out[i][j]+5 : reordered_input_data_arr[i][j];
                mem_in[i][j] = compute.eq(1)? reordered_input_data_arr[i][j]+5 : reordered_input_data_arr[i][j];
                //mem_in[i][j] = compute.eq(1)? mem_out[i][j]+5 : reordered_input_data_arr_skewed[i][j];
            }
        DFEVar mem_out_[][] = Utils.parallelMemories(write_enable, mem_in, reordered_in_memory_addr);
        //DFEVar mem_out_[][] = Utils.parallelMemories(write_enable_skewed, mem_in, reordered_in_memory_addr_skewed);

        //for(int i =0 ; i< p ; i++)
        //    for(int j =0; j< q; j++){
                //mem_out[i][j] <== stream.offset(mem_out_[i][j],-2);
        //        mem_out[i][j] <== mem_out_[i][j];
        //    }
        //TODO trying uncomment above
        //TODO trying remove below
//        DFEVar mem_out[][]=Utils.parallelMemoriesRead(this,reordered_in_memory_addr);
//        for(int i =0 ; i< p ; i++){
//
//            for(int j =0; j< q; j++){
//                optimization.pushNoPipelining();
//                mem_in[i][j] = compute.eq(1)? mem_out[i][j]+5 : reordered_input_data_arr[i][j];
//                optimization.popNoPipelining();
//                //mem_in[i][j] = reordered_input_data_arr[i][j];
//            }
//        }
//        Utils.parallelMemoriesWrite(this, write_enable, mem_in, reordered_in_memory_addr);
        //TODO trying remove above

        DFEVar output_[] = Utils.Crossbar(mem_out_, reordering_signal_i, reordering_signal_j);
        //DFEVar output[] = Utils.Crossbar(mem_out, reordering_signal_i_sk, reordering_signal_j_sk);
        DFEVar output[] = new DFEVar[p*q];
        for(int i =0 ; i< p*q ; i++){
                //The comparison and sum introduce a delay in the loop
                //Skewing the mem_out update to -2 solves the problem, but all the other signal
                //are now wrong and they need to be delayed.
                //however adding the delay does not solve the problem.
                //Debug of the signal in comparison to the working case is required.

                //mem_in[i][j]=reordered_input_data_arr[i][j];
                //mem_in[i][j] = compute.eq(1)? mem_out[i][j]+5 : reordered_input_data_arr[i][j];
                output[i] = compute.eq(2)? output_[i]+1 : output_[i];
                //mem_in[i][j] = compute.eq(1)? mem_out[i][j]+5 : reordered_input_data_arr_skewed[i][j];
            }
        //TODO trying uncomment below
        optimization.popNoPipelining();
        //TODO trying uncomment above
        for(int i =0 ; i< p ; i++)
            for(int j =0; j< q; j++){
                io.output("o_"+i+"_"+j, output[i*q+j], type);
                //io.output("o_"+i+"_"+j,stream.offset( output[i*q+j],-2), type);
            }
    }

}
